// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: json_test.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/Any.pbobjc.h>
 #import <Protobuf/Wrappers.pbobjc.h>
 #import <Protobuf/Timestamp.pbobjc.h>
 #import <Protobuf/Duration.pbobjc.h>
 #import <Protobuf/FieldMask.pbobjc.h>
 #import <Protobuf/Struct.pbobjc.h>
#else
 #import "google/protobuf/Any.pbobjc.h"
 #import "google/protobuf/Wrappers.pbobjc.h"
 #import "google/protobuf/Timestamp.pbobjc.h"
 #import "google/protobuf/Duration.pbobjc.h"
 #import "google/protobuf/FieldMask.pbobjc.h"
 #import "google/protobuf/Struct.pbobjc.h"
#endif

 #import "JsonTest.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - JsonTestRoot

@implementation JsonTestRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[GPBAnyRoot extensionRegistry]];
    [registry addExtensions:[GPBWrappersRoot extensionRegistry]];
    [registry addExtensions:[GPBTimestampRoot extensionRegistry]];
    [registry addExtensions:[GPBDurationRoot extensionRegistry]];
    [registry addExtensions:[GPBFieldMaskRoot extensionRegistry]];
    [registry addExtensions:[GPBStructRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - JsonTestRoot_FileDescriptor

static GPBFileDescriptor *JsonTestRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"json_test"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - VideoAttentItem

@implementation VideoAttentItem

@dynamic attentKey;
@dynamic hasPoster, poster;
@dynamic attentState;
@dynamic lid;
@dynamic cid;
@dynamic vid;
@dynamic updatetime;
@dynamic shortTitle;
@dynamic attentFrom;

typedef struct VideoAttentItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t attentState;
  NSString *attentKey;
  Poster *poster;
  NSString *lid;
  NSString *cid;
  NSString *vid;
  NSString *shortTitle;
  NSString *attentFrom;
  int64_t updatetime;
} VideoAttentItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attentKey",
        .dataTypeSpecific.className = NULL,
        .number = VideoAttentItem_FieldNumber_AttentKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VideoAttentItem__storage_, attentKey),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "poster",
        .dataTypeSpecific.className = GPBStringifySymbol(Poster),
        .number = VideoAttentItem_FieldNumber_Poster,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VideoAttentItem__storage_, poster),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attentState",
        .dataTypeSpecific.className = NULL,
        .number = VideoAttentItem_FieldNumber_AttentState,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VideoAttentItem__storage_, attentState),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lid",
        .dataTypeSpecific.className = NULL,
        .number = VideoAttentItem_FieldNumber_Lid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VideoAttentItem__storage_, lid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = VideoAttentItem_FieldNumber_Cid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VideoAttentItem__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vid",
        .dataTypeSpecific.className = NULL,
        .number = VideoAttentItem_FieldNumber_Vid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VideoAttentItem__storage_, vid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "updatetime",
        .dataTypeSpecific.className = NULL,
        .number = VideoAttentItem_FieldNumber_Updatetime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VideoAttentItem__storage_, updatetime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shortTitle",
        .dataTypeSpecific.className = NULL,
        .number = VideoAttentItem_FieldNumber_ShortTitle,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VideoAttentItem__storage_, shortTitle),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attentFrom",
        .dataTypeSpecific.className = NULL,
        .number = VideoAttentItem_FieldNumber_AttentFrom,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(VideoAttentItem__storage_, attentFrom),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VideoAttentItem class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VideoAttentItem__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\003\013\000\010\n\000\t\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Poster

@implementation Poster

@dynamic firstLine;
@dynamic secondLine;
@dynamic thirdLine;
@dynamic imageURL;
@dynamic playCount;
@dynamic hasAction, action;
@dynamic imageUiType;
@dynamic rating;
@dynamic reportParams;
@dynamic reportKey;

typedef struct Poster__storage_ {
  uint32_t _has_storage_[1];
  uint32_t playCount;
  int32_t imageUiType;
  int32_t rating;
  NSString *firstLine;
  NSString *secondLine;
  NSString *thirdLine;
  NSString *imageURL;
  Action *action;
  NSString *reportParams;
  NSString *reportKey;
} Poster__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "firstLine",
        .dataTypeSpecific.className = NULL,
        .number = Poster_FieldNumber_FirstLine,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Poster__storage_, firstLine),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secondLine",
        .dataTypeSpecific.className = NULL,
        .number = Poster_FieldNumber_SecondLine,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Poster__storage_, secondLine),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thirdLine",
        .dataTypeSpecific.className = NULL,
        .number = Poster_FieldNumber_ThirdLine,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Poster__storage_, thirdLine),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageURL",
        .dataTypeSpecific.className = NULL,
        .number = Poster_FieldNumber_ImageURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Poster__storage_, imageURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playCount",
        .dataTypeSpecific.className = NULL,
        .number = Poster_FieldNumber_PlayCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Poster__storage_, playCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "action",
        .dataTypeSpecific.className = GPBStringifySymbol(Action),
        .number = Poster_FieldNumber_Action,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Poster__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imageUiType",
        .dataTypeSpecific.className = NULL,
        .number = Poster_FieldNumber_ImageUiType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Poster__storage_, imageUiType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rating",
        .dataTypeSpecific.className = NULL,
        .number = Poster_FieldNumber_Rating,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Poster__storage_, rating),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reportParams",
        .dataTypeSpecific.className = NULL,
        .number = Poster_FieldNumber_ReportParams,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Poster__storage_, reportParams),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reportKey",
        .dataTypeSpecific.className = NULL,
        .number = Poster_FieldNumber_ReportKey,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Poster__storage_, reportKey),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Poster class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Poster__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\t\000\002\n\000\003\t\000\005\006!!\000\006\t\000\010\013\000\n\014\000\014\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action

@implementation Action

@dynamic URL;
@dynamic cacheType;
@dynamic preReadType;
@dynamic reportParams;
@dynamic reportKey;

typedef struct Action__storage_ {
  uint32_t _has_storage_[1];
  int32_t cacheType;
  int32_t preReadType;
  NSString *URL;
  NSString *reportParams;
  NSString *reportKey;
} Action__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Action_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cacheType",
        .dataTypeSpecific.className = NULL,
        .number = Action_FieldNumber_CacheType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action__storage_, cacheType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "preReadType",
        .dataTypeSpecific.className = NULL,
        .number = Action_FieldNumber_PreReadType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action__storage_, preReadType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reportParams",
        .dataTypeSpecific.className = NULL,
        .number = Action_FieldNumber_ReportParams,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Action__storage_, reportParams),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reportKey",
        .dataTypeSpecific.className = NULL,
        .number = Action_FieldNumber_ReportKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Action__storage_, reportKey),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001!!!\000\002\t\000\003\013\000\004\014\000\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestAllTypes

@implementation TestAllTypes

@dynamic reportKey;
@dynamic optionalInt32;
@dynamic optionalInt64;
@dynamic optionalUint32;
@dynamic optionalUint64;
@dynamic optionalSint32;
@dynamic optionalSint64;
@dynamic optionalFixed32;
@dynamic optionalFixed64;
@dynamic optionalSfixed32;
@dynamic optionalSfixed64;
@dynamic optionalFloat;
@dynamic optionalDouble;
@dynamic optionalBool;
@dynamic optionalString;
@dynamic optionalBytes;
@dynamic hasOptionalNestedMessage, optionalNestedMessage;
@dynamic optionalNestedEnum;
@dynamic repeatedInt32Array, repeatedInt32Array_Count;
@dynamic repeatedInt64Array, repeatedInt64Array_Count;
@dynamic repeatedUint32Array, repeatedUint32Array_Count;
@dynamic repeatedUint64Array, repeatedUint64Array_Count;
@dynamic repeatedSint32Array, repeatedSint32Array_Count;
@dynamic repeatedSint64Array, repeatedSint64Array_Count;
@dynamic repeatedFixed32Array, repeatedFixed32Array_Count;
@dynamic repeatedFixed64Array, repeatedFixed64Array_Count;
@dynamic repeatedSfixed32Array, repeatedSfixed32Array_Count;
@dynamic repeatedSfixed64Array, repeatedSfixed64Array_Count;
@dynamic repeatedFloatArray, repeatedFloatArray_Count;
@dynamic repeatedDoubleArray, repeatedDoubleArray_Count;
@dynamic repeatedBoolArray, repeatedBoolArray_Count;
@dynamic repeatedStringArray, repeatedStringArray_Count;
@dynamic repeatedBytesArray, repeatedBytesArray_Count;
@dynamic repeatedNestedMessageArray, repeatedNestedMessageArray_Count;
@dynamic repeatedNestedEnumArray, repeatedNestedEnumArray_Count;

typedef struct TestAllTypes__storage_ {
  uint32_t _has_storage_[1];
  int32_t optionalInt32;
  uint32_t optionalUint32;
  int32_t optionalSint32;
  uint32_t optionalFixed32;
  int32_t optionalSfixed32;
  float optionalFloat;
  TestAllTypes_NestedEnum optionalNestedEnum;
  NSString *optionalString;
  NSData *optionalBytes;
  TestAllTypes_NestedMessage *optionalNestedMessage;
  GPBInt32Array *repeatedInt32Array;
  GPBInt64Array *repeatedInt64Array;
  GPBUInt32Array *repeatedUint32Array;
  GPBUInt64Array *repeatedUint64Array;
  GPBInt32Array *repeatedSint32Array;
  GPBInt64Array *repeatedSint64Array;
  GPBUInt32Array *repeatedFixed32Array;
  GPBUInt64Array *repeatedFixed64Array;
  GPBInt32Array *repeatedSfixed32Array;
  GPBInt64Array *repeatedSfixed64Array;
  GPBFloatArray *repeatedFloatArray;
  GPBDoubleArray *repeatedDoubleArray;
  GPBBoolArray *repeatedBoolArray;
  NSMutableArray *repeatedStringArray;
  NSMutableArray *repeatedBytesArray;
  NSMutableArray *repeatedNestedMessageArray;
  GPBEnumArray *repeatedNestedEnumArray;
  NSString *reportKey;
  int64_t optionalInt64;
  uint64_t optionalUint64;
  int64_t optionalSint64;
  uint64_t optionalFixed64;
  int64_t optionalSfixed64;
  double optionalDouble;
} TestAllTypes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "optionalInt32",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalInt32,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalInt32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "optionalInt64",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalInt64,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalInt64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "optionalUint32",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalUint32,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalUint32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "optionalUint64",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalUint64,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalUint64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "optionalSint32",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalSint32,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalSint32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "optionalSint64",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalSint64,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalSint64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "optionalFixed32",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalFixed32,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalFixed32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "optionalFixed64",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalFixed64,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalFixed64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "optionalSfixed32",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalSfixed32,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalSfixed32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed32,
      },
      {
        .name = "optionalSfixed64",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalSfixed64,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalSfixed64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed64,
      },
      {
        .name = "optionalFloat",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalFloat,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalFloat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "optionalDouble",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalDouble,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalDouble),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "optionalBool",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalBool,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "optionalString",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalString,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "optionalBytes",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_OptionalBytes,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "optionalNestedMessage",
        .dataTypeSpecific.className = GPBStringifySymbol(TestAllTypes_NestedMessage),
        .number = TestAllTypes_FieldNumber_OptionalNestedMessage,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalNestedMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "optionalNestedEnum",
        .dataTypeSpecific.enumDescFunc = TestAllTypes_NestedEnum_EnumDescriptor,
        .number = TestAllTypes_FieldNumber_OptionalNestedEnum,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, optionalNestedEnum),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "repeatedInt32Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedInt32Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedInt32Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "repeatedInt64Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedInt64Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedInt64Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "repeatedUint32Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedUint32Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedUint32Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "repeatedUint64Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedUint64Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedUint64Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "repeatedSint32Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedSint32Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedSint32Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "repeatedSint64Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedSint64Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedSint64Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "repeatedFixed32Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedFixed32Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedFixed32Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "repeatedFixed64Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedFixed64Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedFixed64Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "repeatedSfixed32Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedSfixed32Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedSfixed32Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeSFixed32,
      },
      {
        .name = "repeatedSfixed64Array",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedSfixed64Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedSfixed64Array),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeSFixed64,
      },
      {
        .name = "repeatedFloatArray",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedFloatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedFloatArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "repeatedDoubleArray",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedDoubleArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedDoubleArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "repeatedBoolArray",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedBoolArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedBoolArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "repeatedStringArray",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedStringArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedStringArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "repeatedBytesArray",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_RepeatedBytesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedBytesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "repeatedNestedMessageArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TestAllTypes_NestedMessage),
        .number = TestAllTypes_FieldNumber_RepeatedNestedMessageArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedNestedMessageArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "repeatedNestedEnumArray",
        .dataTypeSpecific.enumDescFunc = TestAllTypes_NestedEnum_EnumDescriptor,
        .number = TestAllTypes_FieldNumber_RepeatedNestedEnumArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, repeatedNestedEnumArray),
        .flags = GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "reportKey",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_FieldNumber_ReportKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestAllTypes__storage_, reportKey),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestAllTypes class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestAllTypes__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\364\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TestAllTypes_OptionalNestedEnum_RawValue(TestAllTypes *message) {
  GPBDescriptor *descriptor = [TestAllTypes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TestAllTypes_FieldNumber_OptionalNestedEnum];
  return GPBGetMessageInt32Field(message, field);
}

void SetTestAllTypes_OptionalNestedEnum_RawValue(TestAllTypes *message, int32_t value) {
  GPBDescriptor *descriptor = [TestAllTypes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TestAllTypes_FieldNumber_OptionalNestedEnum];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum TestAllTypes_NestedEnum

GPBEnumDescriptor *TestAllTypes_NestedEnum_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Foo\000Bar\000Baz\000";
    static const int32_t values[] = {
        TestAllTypes_NestedEnum_Foo,
        TestAllTypes_NestedEnum_Bar,
        TestAllTypes_NestedEnum_Baz,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TestAllTypes_NestedEnum)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TestAllTypes_NestedEnum_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TestAllTypes_NestedEnum_IsValidValue(int32_t value__) {
  switch (value__) {
    case TestAllTypes_NestedEnum_Foo:
    case TestAllTypes_NestedEnum_Bar:
    case TestAllTypes_NestedEnum_Baz:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TestAllTypes_NestedMessage

@implementation TestAllTypes_NestedMessage

@dynamic value;
@dynamic str;

typedef struct TestAllTypes_NestedMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
  NSString *str;
} TestAllTypes_NestedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_NestedMessage_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestAllTypes_NestedMessage__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "str",
        .dataTypeSpecific.className = NULL,
        .number = TestAllTypes_NestedMessage_FieldNumber_Str,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TestAllTypes_NestedMessage__storage_, str),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestAllTypes_NestedMessage class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestAllTypes_NestedMessage__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestOneof

@implementation TestOneof

@dynamic oneofFieldOneOfCase;
@dynamic oneofInt32;
@dynamic oneofNestedMessage;

typedef struct TestOneof__storage_ {
  uint32_t _has_storage_[2];
  int32_t oneofInt32;
  TestAllTypes_NestedMessage *oneofNestedMessage;
} TestOneof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oneofInt32",
        .dataTypeSpecific.className = NULL,
        .number = TestOneof_FieldNumber_OneofInt32,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TestOneof__storage_, oneofInt32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "oneofNestedMessage",
        .dataTypeSpecific.className = GPBStringifySymbol(TestAllTypes_NestedMessage),
        .number = TestOneof_FieldNumber_OneofNestedMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TestOneof__storage_, oneofNestedMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestOneof class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestOneof__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "oneofField",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TestOneof_ClearOneofFieldOneOfCase(TestOneof *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - TestMap

@implementation TestMap

@dynamic int32ToInt32Map, int32ToInt32Map_Count;
@dynamic int64ToInt32Map, int64ToInt32Map_Count;
@dynamic uint32ToInt32Map, uint32ToInt32Map_Count;
@dynamic uint64ToInt32Map, uint64ToInt32Map_Count;
@dynamic sint32ToInt32Map, sint32ToInt32Map_Count;
@dynamic sint64ToInt32Map, sint64ToInt32Map_Count;
@dynamic fixed32ToInt32Map, fixed32ToInt32Map_Count;
@dynamic fixed64ToInt32Map, fixed64ToInt32Map_Count;
@dynamic sfixed32ToInt32Map, sfixed32ToInt32Map_Count;
@dynamic sfixed64ToInt32Map, sfixed64ToInt32Map_Count;
@dynamic boolToInt32Map, boolToInt32Map_Count;
@dynamic stringToInt32Map, stringToInt32Map_Count;
@dynamic int32ToInt64Map, int32ToInt64Map_Count;
@dynamic int32ToUint32Map, int32ToUint32Map_Count;
@dynamic int32ToUint64Map, int32ToUint64Map_Count;
@dynamic int32ToSint32Map, int32ToSint32Map_Count;
@dynamic int32ToSint64Map, int32ToSint64Map_Count;
@dynamic int32ToFixed32Map, int32ToFixed32Map_Count;
@dynamic int32ToFixed64Map, int32ToFixed64Map_Count;
@dynamic int32ToSfixed32Map, int32ToSfixed32Map_Count;
@dynamic int32ToSfixed64Map, int32ToSfixed64Map_Count;
@dynamic int32ToFloatMap, int32ToFloatMap_Count;
@dynamic int32ToDoubleMap, int32ToDoubleMap_Count;
@dynamic int32ToBoolMap, int32ToBoolMap_Count;
@dynamic int32ToStringMap, int32ToStringMap_Count;
@dynamic int32ToBytesMap, int32ToBytesMap_Count;
@dynamic int32ToMessageMap, int32ToMessageMap_Count;
@dynamic int32ToEnumMap, int32ToEnumMap_Count;

typedef struct TestMap__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Int32Dictionary *int32ToInt32Map;
  GPBInt64Int32Dictionary *int64ToInt32Map;
  GPBUInt32Int32Dictionary *uint32ToInt32Map;
  GPBUInt64Int32Dictionary *uint64ToInt32Map;
  GPBInt32Int32Dictionary *sint32ToInt32Map;
  GPBInt64Int32Dictionary *sint64ToInt32Map;
  GPBUInt32Int32Dictionary *fixed32ToInt32Map;
  GPBUInt64Int32Dictionary *fixed64ToInt32Map;
  GPBInt32Int32Dictionary *sfixed32ToInt32Map;
  GPBInt64Int32Dictionary *sfixed64ToInt32Map;
  GPBBoolInt32Dictionary *boolToInt32Map;
  GPBStringInt32Dictionary *stringToInt32Map;
  GPBInt32Int64Dictionary *int32ToInt64Map;
  GPBInt32UInt32Dictionary *int32ToUint32Map;
  GPBInt32UInt64Dictionary *int32ToUint64Map;
  GPBInt32Int32Dictionary *int32ToSint32Map;
  GPBInt32Int64Dictionary *int32ToSint64Map;
  GPBInt32UInt32Dictionary *int32ToFixed32Map;
  GPBInt32UInt64Dictionary *int32ToFixed64Map;
  GPBInt32Int32Dictionary *int32ToSfixed32Map;
  GPBInt32Int64Dictionary *int32ToSfixed64Map;
  GPBInt32FloatDictionary *int32ToFloatMap;
  GPBInt32DoubleDictionary *int32ToDoubleMap;
  GPBInt32BoolDictionary *int32ToBoolMap;
  GPBInt32ObjectDictionary *int32ToStringMap;
  GPBInt32ObjectDictionary *int32ToBytesMap;
  GPBInt32ObjectDictionary *int32ToMessageMap;
  GPBInt32EnumDictionary *int32ToEnumMap;
} TestMap__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "int32ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToInt32Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "int64ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int64ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int64ToInt32Map),
        .flags = GPBFieldMapKeyInt64,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "uint32ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Uint32ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, uint32ToInt32Map),
        .flags = GPBFieldMapKeyUInt32,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "uint64ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Uint64ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, uint64ToInt32Map),
        .flags = GPBFieldMapKeyUInt64,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sint32ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Sint32ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, sint32ToInt32Map),
        .flags = GPBFieldMapKeySInt32,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sint64ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Sint64ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, sint64ToInt32Map),
        .flags = GPBFieldMapKeySInt64,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fixed32ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Fixed32ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, fixed32ToInt32Map),
        .flags = GPBFieldMapKeyFixed32,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fixed64ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Fixed64ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, fixed64ToInt32Map),
        .flags = GPBFieldMapKeyFixed64,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sfixed32ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Sfixed32ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, sfixed32ToInt32Map),
        .flags = GPBFieldMapKeySFixed32,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sfixed64ToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Sfixed64ToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, sfixed64ToInt32Map),
        .flags = GPBFieldMapKeySFixed64,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "boolToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_BoolToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, boolToInt32Map),
        .flags = GPBFieldMapKeyBool,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stringToInt32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_StringToInt32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, stringToInt32Map),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "int32ToInt64Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToInt64Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToInt64Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "int32ToUint32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToUint32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToUint32Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "int32ToUint64Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToUint64Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToUint64Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "int32ToSint32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToSint32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToSint32Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "int32ToSint64Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToSint64Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToSint64Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "int32ToFixed32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToFixed32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToFixed32Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "int32ToFixed64Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToFixed64Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToFixed64Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "int32ToSfixed32Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToSfixed32Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToSfixed32Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeSFixed32,
      },
      {
        .name = "int32ToSfixed64Map",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToSfixed64Map,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToSfixed64Map),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeSFixed64,
      },
      {
        .name = "int32ToFloatMap",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToFloatMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToFloatMap),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "int32ToDoubleMap",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToDoubleMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToDoubleMap),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "int32ToBoolMap",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToBoolMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToBoolMap),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "int32ToStringMap",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToStringMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToStringMap),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "int32ToBytesMap",
        .dataTypeSpecific.className = NULL,
        .number = TestMap_FieldNumber_Int32ToBytesMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToBytesMap),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "int32ToMessageMap",
        .dataTypeSpecific.className = GPBStringifySymbol(TestAllTypes_NestedMessage),
        .number = TestMap_FieldNumber_Int32ToMessageMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToMessageMap),
        .flags = GPBFieldMapKeyInt32,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "int32ToEnumMap",
        .dataTypeSpecific.enumDescFunc = TestAllTypes_NestedEnum_EnumDescriptor,
        .number = TestMap_FieldNumber_Int32ToEnumMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TestMap__storage_, int32ToEnumMap),
        .flags = GPBFieldMapKeyInt32 | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestMap class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestMap__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestWrappers

@implementation TestWrappers

@dynamic hasInt32Value, int32Value;
@dynamic hasUint32Value, uint32Value;
@dynamic hasInt64Value, int64Value;
@dynamic hasUint64Value, uint64Value;
@dynamic hasFloatValue, floatValue;
@dynamic hasDoubleValue, doubleValue;
@dynamic hasBoolValue, boolValue;
@dynamic hasStringValue, stringValue;
@dynamic hasBytesValue, bytesValue;

typedef struct TestWrappers__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Value *int32Value;
  GPBUInt32Value *uint32Value;
  GPBInt64Value *int64Value;
  GPBUInt64Value *uint64Value;
  GPBFloatValue *floatValue;
  GPBDoubleValue *doubleValue;
  GPBBoolValue *boolValue;
  GPBStringValue *stringValue;
  GPBBytesValue *bytesValue;
} TestWrappers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "int32Value",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBInt32Value),
        .number = TestWrappers_FieldNumber_Int32Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestWrappers__storage_, int32Value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uint32Value",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUInt32Value),
        .number = TestWrappers_FieldNumber_Uint32Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TestWrappers__storage_, uint32Value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "int64Value",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBInt64Value),
        .number = TestWrappers_FieldNumber_Int64Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TestWrappers__storage_, int64Value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uint64Value",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUInt64Value),
        .number = TestWrappers_FieldNumber_Uint64Value,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TestWrappers__storage_, uint64Value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "floatValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBFloatValue),
        .number = TestWrappers_FieldNumber_FloatValue,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TestWrappers__storage_, floatValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "doubleValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBDoubleValue),
        .number = TestWrappers_FieldNumber_DoubleValue,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TestWrappers__storage_, doubleValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "boolValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBBoolValue),
        .number = TestWrappers_FieldNumber_BoolValue,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TestWrappers__storage_, boolValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stringValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStringValue),
        .number = TestWrappers_FieldNumber_StringValue,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TestWrappers__storage_, stringValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bytesValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBBytesValue),
        .number = TestWrappers_FieldNumber_BytesValue,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(TestWrappers__storage_, bytesValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestWrappers class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestWrappers__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestTimestamp

@implementation TestTimestamp

@dynamic hasTimestampValue, timestampValue;

typedef struct TestTimestamp__storage_ {
  uint32_t _has_storage_[1];
  GPBTimestamp *timestampValue;
} TestTimestamp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestampValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = TestTimestamp_FieldNumber_TimestampValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestTimestamp__storage_, timestampValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestTimestamp class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestTimestamp__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestDuration

@implementation TestDuration

@dynamic hasDurationValue, durationValue;

typedef struct TestDuration__storage_ {
  uint32_t _has_storage_[1];
  GPBDuration *durationValue;
} TestDuration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "durationValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBDuration),
        .number = TestDuration_FieldNumber_DurationValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestDuration__storage_, durationValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestDuration class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestDuration__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestFieldMask

@implementation TestFieldMask

@dynamic hasFieldMaskValue, fieldMaskValue;

typedef struct TestFieldMask__storage_ {
  uint32_t _has_storage_[1];
  GPBFieldMask *fieldMaskValue;
} TestFieldMask__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fieldMaskValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBFieldMask),
        .number = TestFieldMask_FieldNumber_FieldMaskValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestFieldMask__storage_, fieldMaskValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestFieldMask class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestFieldMask__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestStruct

@implementation TestStruct

@dynamic hasStructValue, structValue;
@dynamic hasValue, value;
@dynamic hasListValue, listValue;

typedef struct TestStruct__storage_ {
  uint32_t _has_storage_[1];
  GPBStruct *structValue;
  GPBValue *value;
  GPBListValue *listValue;
} TestStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "structValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBStruct),
        .number = TestStruct_FieldNumber_StructValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestStruct__storage_, structValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBValue),
        .number = TestStruct_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TestStruct__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBListValue),
        .number = TestStruct_FieldNumber_ListValue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TestStruct__storage_, listValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestStruct class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestStruct__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestAny

@implementation TestAny

@dynamic hasAnyValue, anyValue;

typedef struct TestAny__storage_ {
  uint32_t _has_storage_[1];
  GPBAny *anyValue;
} TestAny__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "anyValue",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = TestAny_FieldNumber_AnyValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestAny__storage_, anyValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestAny class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestAny__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TestCustomJsonName

@implementation TestCustomJsonName

@dynamic value;

typedef struct TestCustomJsonName__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
} TestCustomJsonName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = TestCustomJsonName_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TestCustomJsonName__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TestCustomJsonName class]
                                     rootClass:[JsonTestRoot class]
                                          file:JsonTestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TestCustomJsonName__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
